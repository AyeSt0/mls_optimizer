# -*- coding: utf-8 -*-
"""
MLS Optimizer — Patched (colmap v2)
Column mapping (0-based):
  col0: RU (optional)
  col1: EN
  col2: Speaker
  col3: EN-mixed (EN with inline zh/markers)  <-- seed column used by step 20
  col4: ZH_NEW (target)                       <-- all later steps operate here
This file is generated by ChatGPT to fix column layout and pipeline order.
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import subprocess, os, sys, threading, time

I18N = {
    "zh": {
        "title": "MLS 优化器（流水线）",
        "excel": "Excel 文件",
        "glossary": "术语表",
        "target": "目标语言",
        "run": "运行",
        "dry": "仅预览",
        "overwrite": "覆盖已有译文（重译）",
        "rowrange": "行号范围",
        "speaker": "Speaker 过滤（*通配）",
        "log": "运行日志",
        "menu_file": "文件",
        "menu_conf": "配置",
        "menu_help": "帮助",
        "pick_xlsx": "选择 Excel",
        "pick_gloss": "选择术语表",
        "api_setup": "API 设置…",
        "ok": "确定",
    },
    "en": {
        "title": "MLS Optimizer (Pipeline)",
        "excel": "Excel",
        "glossary": "Glossary",
        "target": "Target Lang",
        "run": "Run",
        "dry": "Dry run",
        "overwrite": "Overwrite existing",
        "rowrange": "Row range",
        "speaker": "Speaker filter (* glob)",
        "log": "Logs",
        "menu_file": "File",
        "menu_conf": "Config",
        "menu_help": "Help",
        "pick_xlsx": "Pick Excel",
        "pick_gloss": "Pick Glossary",
        "api_setup": "API Settings…",
        "ok": "OK",
    }
}

class App:
    def __init__(self, root):
        self.root = root
        self.lang = "zh"
        t = I18N[self.lang]
        root.title(t["title"])
        self.excel = tk.StringVar(value="data/MLS Chinese.xlsx")
        self.glossary = tk.StringVar(value="data/name_map.json")
        self.target = tk.StringVar(value="zh-CN")
        self.rowrange = tk.StringVar(value="")
        self.spk = tk.StringVar(value="")
        self.overwrite = tk.BooleanVar(value=False)
        self.dry = tk.BooleanVar(value=False)

        self._build_menu()
        self._build_ui(t)
        self._log_lock = threading.Lock()

    def _build_menu(self):
        t = I18N[self.lang]
        menubar = tk.Menu(self.root)
        m_file = tk.Menu(menubar, tearoff=0)
        m_file.add_command(label=t["pick_xlsx"], command=self.pick_excel)
        m_file.add_command(label=t["pick_gloss"], command=self.pick_glossary)
        menubar.add_cascade(label=t["menu_file"], menu=m_file)

        m_conf = tk.Menu(menubar, tearoff=0)
        m_conf.add_command(label=t["api_setup"], command=self.api_settings)
        menubar.add_cascade(label=t["menu_conf"], menu=m_conf)

        m_help = tk.Menu(menubar, tearoff=0)
        m_help.add_command(label="README", command=lambda:self._open("README.md"))
        menubar.add_cascade(label=t["menu_help"], menu=m_help)

        self.root.config(menu=menubar)
        self._menubar = menubar
        self._m_file, self._m_conf, self._m_help = m_file, m_conf, m_help

    def _build_ui(self, t):
        frm = ttk.Frame(self.root, padding=8)
        frm.pack(fill="both", expand=True)

        r0 = ttk.Frame(frm); r0.pack(fill="x", pady=4)
        ttk.Label(r0, text=t["excel"]).pack(side="left")
        ttk.Entry(r0, textvariable=self.excel, width=60).pack(side="left", padx=6)
        ttk.Button(r0, text="…", command=self.pick_excel, width=3).pack(side="left")

        r1 = ttk.Frame(frm); r1.pack(fill="x", pady=4)
        ttk.Label(r1, text=t["glossary"]).pack(side="left")
        ttk.Entry(r1, textvariable=self.glossary, width=60).pack(side="left", padx=6)
        ttk.Button(r1, text="…", command=self.pick_glossary, width=3).pack(side="left")

        r2 = ttk.Frame(frm); r2.pack(fill="x", pady=4)
        ttk.Label(r2, text=t["target"]).pack(side="left")
        ttk.Entry(r2, textvariable=self.target, width=12).pack(side="left", padx=6)
        ttk.Checkbutton(r2, text=t["overwrite"], variable=self.overwrite).pack(side="left", padx=12)
        ttk.Checkbutton(r2, text=t["dry"], variable=self.dry).pack(side="left", padx=12)

        r3 = ttk.Frame(frm); r3.pack(fill="x", pady=4)
        ttk.Label(r3, text=t["rowrange"]).pack(side="left")
        ttk.Entry(r3, textvariable=self.rowrange, width=16).pack(side="left", padx=6)
        ttk.Label(r3, text=t["speaker"]).pack(side="left", padx=(16,0))
        ttk.Entry(r3, textvariable=self.spk, width=20).pack(side="left", padx=6)

        r4 = ttk.Frame(frm); r4.pack(fill="x", pady=6)
        ttk.Button(r4, text=t["run"], command=self.run_pipeline, width=12).pack(side="left")

        # Logs
        lf = ttk.LabelFrame(frm, text=t["log"]); lf.pack(fill="both", expand=True, pady=6)
        self.txt = tk.Text(lf, height=18, wrap="word")
        self.txt.pack(fill="both", expand=True, padx=6, pady=6)
        sb = ttk.Scrollbar(self.txt, command=self.txt.yview); self.txt["yscrollcommand"]=sb.set
        sb.pack(side="right", fill="y")

        # Lang toggle
        ttk.Button(frm, text="EN/中文", command=self.toggle_lang).pack(anchor="ne")

    def _open(self, path):
        try:
            if os.name == "nt":
                os.startfile(path)  # type: ignore
            else:
                subprocess.Popen(["xdg-open", path])
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def pick_excel(self):
        path = filedialog.askopenfilename(filetypes=[("Excel","*.xlsx")])
        if path: self.excel.set(path)

    def pick_glossary(self):
        path = filedialog.askopenfilename(filetypes=[("JSON","*.json"),("All","*.*")])
        if path: self.glossary.set(path)

    def api_settings(self):
        top = tk.Toplevel(self.root); top.title(I18N[self.lang]["api_setup"])
        tk.Label(top, text="config/settings.local.yaml will be used.\n请直接编辑该文件以设置 provider/base_url/api_key。").pack(padx=12, pady=12)
        ttk.Button(top, text=I18N[self.lang]["ok"], command=top.destroy).pack(pady=8)

    def log(self, s:str):
        with self._log_lock:
            self.txt.insert("end", s+"\n")
            self.txt.see("end")
            self.txt.update_idletasks()

    def run_pipeline(self):
        xlsx = self.excel.get().strip()
        gloss = self.glossary.get().strip()
        target = self.target.get().strip() or "zh-CN"
        rowr = self.rowrange.get().strip()
        spk = self.spk.get().strip()
        overwrite = self.overwrite.get()
        dry = self.dry.get()

        if not os.path.exists(xlsx):
            messagebox.showerror("Error", f"Excel not found: {xlsx}")
            return
        if not os.path.exists(gloss):
            messagebox.showwarning("Warn", f"Glossary not found: {gloss}")

        cmds = []

        # 05 segment
        cmds.append([sys.executable, "-u", "-m", "scripts.05_segment_context", "--excel", xlsx, "--sheet-index", "0"])

        # 20 pre-enforce (seed col4 from col3 + protect)
        c20 = [sys.executable, "-u", "-m", "scripts.20_enforce_terms", "--excel", xlsx, "--sheet", "0"]
        if os.path.exists(gloss): c20 += ["--glossary", gloss]
        c20 += ["--overwrite"]  # always seed from col3 to col4
        cmds.append(c20)

        # 12 translate
        c12 = [sys.executable, "-u", "-m", "scripts.12_llm_translate", "--excel", xlsx, "--sheet-index", "0",
               "--target-lang", target, "--glossary", gloss, "--show-lines"]
        if rowr: c12 += ["--row-range", rowr]
        if spk:  c12 += ["--speaker-filter", spk]
        if overwrite: c12 += ["--overwrite"]
        if dry: c12 += ["--dry-run"]
        cmds.append(c12)

        # 21 enforce-again
        if os.path.exists(gloss):
            cmds.append([sys.executable, "-u", "-m", "scripts.21_enforce_terms_again", "--excel", xlsx, "--sheet", "0", "--glossary", gloss])

        # 22 stats
        if os.path.exists("scripts/22_terms_stats.py"):
            cmds.append([sys.executable, "-u", "-m", "scripts.22_terms_stats", "--excel", xlsx])

        # 30 style
        if os.path.exists("scripts/30_style_adapt.py"):
            cmds.append([sys.executable, "-u", "-m", "scripts.30_style_adapt", "--excel", xlsx])

        # 25 QA
        if os.path.exists("scripts/25_qa_check.py"):
            cmds.append([sys.executable, "-u", "-m", "scripts.25_qa_check", "--excel", xlsx])

        # 90 release
        if os.path.exists("scripts/90_release_notes.py"):
            cmds.append([sys.executable, "-u", "-m", "scripts.90_release_notes", "--excel", xlsx])

        def run_thread():
            self.log("[INFO] 开始运行流水线…")
            for i, cmd in enumerate(cmds, start=1):
                self.log(f"== Step {i}/{len(cmds)} ==\n$ {' '.join(cmd)}")
                try:
                    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
                    for line in iter(p.stdout.readline, ''):
                        self.log(line.rstrip("\n"))
                    p.wait()
                    rc = p.returncode
                    if rc != 0:
                        self.log(f"[ERROR] step failed: rc={rc}")
                        break
                    self.log("[OK] 步骤完成。")
                except Exception as e:
                    self.log(f"[EXC] {e}")
                    break
            self.log("[INFO] 全部结束。")

        threading.Thread(target=run_thread, daemon=True).start()

    def toggle_lang(self):
        self.lang = "en" if self.lang == "zh" else "zh"
        t = I18N[self.lang]
        self.root.title(t["title"])
        # rebuild menu text
        self._menubar.delete(0, "end")
        self._build_menu()
        # rebuild labels
        for w in self.root.pack_slaves():
            w.destroy()
        self._build_ui(t)

def main():
    root = tk.Tk()
    root.geometry("900x600")
    App(root)
    root.mainloop()

if __name__ == "__main__":
    main()
